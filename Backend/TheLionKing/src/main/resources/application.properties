server.port=8181

logging.level.root=INFO
spring.application.name=TheLionKing
#spring.h2.console.enabled=true
#spring.datasource.url=jdbc:h2:mem:tlk
#spring.datasource.url=jdbc:h2:file:~/h2
#spring.datasource.driver-class-name=org.h2.Driver
#spring.datasource.username=sa
#spring.datasource.password=password
#spring.datasource.driverClassName=org.h2.Driver
#spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
#spring.jpa.hibernate.ddl-auto=update

spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
spring.datasource.username=postgres
spring.datasource.password=changemeinprod!
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update

# Docling REST configuration (local Docker container from docker-compose.docling.yml)
docling.base-url=${DOCLING_BASE_URL:http://localhost:5001}
docling.convert-file-path=/v1/convert/file
docling.api-key=${DOCLING_API_KEY:}

# LLM (WatsonX) configuration based on the notebook
llm.base-url=https://eu-de.ml.cloud.ibm.com
# Watsonx endpoints will use /ml/v1/text/generation?version={llm.version-date}
llm.version-date=2025-09-19
llm.project-id=995ba95c-cecd-4d6f-b5cf-96dcd71d8b1e
llm.model-id=meta-llama/llama-3-2-90b-vision-instruct
# Prefer environment variable for API key (IAM)
llm.api-key=${WATSONX_APIKEY:aA0y_IlhJ9BC5__fl4rjZsyC6GoQ4T2Zrc5UFwVWwSr_}

# Centralized prompts
# 1) Group pages into logical documents. Must return ONLY JSON: {"groups":[[pageIndex...], ...]}
prompts.page-grouping=You are an expert at grouping PDF pages into logical documents. Input is a JSON array of objects with fields "index" (0-based integer) and "markdown" (string of page content).\nRules: 1) Preserve original order of pages within each group. 2) Use the provided 0-based indices exactly. 3) Be conservative: if unsure, leave a page as its own group. 4) Output VALID JSON only with no explanations, no markdown fences. 5) Top-level must be a single object with key "groups" mapping to an array of integer arrays. 6) If you cannot produce valid JSON, output {"groups":[[i0],[i1],...]} where each provided index is alone in its own group.\nExpected JSON format: {"groups": [[0,1,2],[3],[4,5]]}

# 1b) Filter pages with no meaningful content; return {"use": true|false}
prompts.page-usability=You are an expert at judging whether a single page of text contains content. Input is a Markdown string for one page.\nRules: 1) If the content is empty, whitespace, boilerplate-only (page numbers), set use=false. 2) Otherwise set use=true. 3) Output VALID JSON only with no explanations or fences. 4) Top-level must be a single object with exactly the key "use" (boolean). 5) If you cannot produce valid JSON, output {"use": false}.\nExpected JSON format: {"use": true}

# 2) Extract fields for each merged document (primary/secondary/tertiary variants)
prompts.document-extraction-primary=You are an expert at extracting key fields from German administrative documents. Input is a JSON array of Markdown strings for a single merged document (all its pages). Produce exactly this JSON object with these keys: category(one of AUSWEIS,GEBURTSURKUNDE,STERBEURKUNDE,ZEUGNIS,STEUERBESCHEID,KRANKENKASSENBESCHEINIGUNG,SONSTIGE), firstName, surname, vsnr, birthDate(YYYY-MM-DD), summary, additionalFields(object).\nRules: 1) The field "summary" MUST be a concise German summary (2-3 Saetze) ohne Tabellen Ueberschriften, Trennlinien oder Spaltennamen (z. B. "Vorerkrankungen", "Behandelnder Arzt", "Krankenhausbehandlung", "Rehabilitation"). 2) Entferne Markdown-Formatierung, Kopf-/Fusszeilen und Duplikate. 3) Verwende null fuer unbekannte Werte. 4) Output VALID JSON only mit keinen Erklaerungen oder Markdown-Fences. 5) Top-Level ist genau ein Objekt mit exakt den genannten Schluesseln (keine zusaetzlichen Schluessel, keine trailing commas). 6) Keep date format strictly YYYY-MM-DD. 7) Falls kein gueltiges JSON moeglich ist, liefere das Expected JSON mit allen Keys und null (additionalFields als {} ).\nExpected JSON format: {"category":null,"firstName":null,"surname":null,"vsnr":null,"birthDate":null,"summary":null,"additionalFields":{}}
prompts.document-extraction-secondary=Given the same Markdown array, fill any missing fields conservatively (do not invent values). Output VALID JSON only, same keys as above, no explanations or fences, unknowns must be null. If you cannot produce valid JSON, output the Expected JSON format with all keys present and null values.
prompts.document-extraction-tertiary=Final validation pass: ensure the output is strictly valid JSON with exactly the specified keys and correct types. No extra text, no fences. Unknowns must be null. If you cannot produce valid JSON, output the Expected JSON format with all keys present and null values.

# 3) Aggregate fields across all sub-documents into overall Antrag fields
prompts.application-aggregation=You are aggregating fields across multiple sub-documents. Input is a JSON array of objects with fields: category, firstName, surname, vsnr, birthDate, summary, additionalFields. Infer the most likely overall fields for the Antrag.\nRules: 1) Prefer values that agree across most sub-documents. 2) If values conflict or are absent, use null. 3) Output VALID JSON only with no explanations or fences. 4) Top-level must be a single object containing exactly the keys: firstName, surname, vsnr, birthDate, summary. 5) Keep date format strictly YYYY-MM-DD. 6) If you cannot produce valid JSON, output the Expected JSON format with all keys present and null values.\nExpected JSON format: {"firstName":null,"surname":null,"vsnr":null,"birthDate":null,"summary":null}





